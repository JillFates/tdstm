package net.transitionmanager.domain

import com.tdsops.tm.enums.domain.ImportBatchStatusEnum
import com.tdsops.tm.enums.domain.ImportOperationEnum
import com.tdssrc.grails.JsonUtil
import org.codehaus.groovy.grails.web.json.JSONObject
/**
 * ImportBatchRecord
 *
 * Used to represent a single row of information about a single domain record. This will contain discrete
 * properties as well as a complex JSON structure of data about each property that will be manipulated within
 * the domain object.
 */
class ImportBatchRecord {
	ImportBatch importBatch

	// The status of the individual record
	ImportBatchStatusEnum status = ImportBatchStatusEnum.PENDING

	// The type of operation that will/was performed on the record (Insert, Update, Delete, Undetermined)
	ImportOperationEnum operation

	// The id found by the lookup operation when only reference was found. This would be the primary
	// id of the domain being UPDATED or DELETED.
	Long domainPrimaryId

	// The row index within the data source that the current record originated
	Integer sourceRowId = 0

	// The number of attributes that have errors in the fieldsInfo JSON specification
	Integer errorCount = 0

	// A flag that indicates that the record will be/was ignored by the batch process
	Integer ignored = 0

	// A flag that indicates that the record can not be automatically posted without warning the user of
	// some concern. If set, the warning will be associated to one or more individual properties.
	Integer warn = 0

	// A flag that indicates that one or more of the reference find operations during the ETL process found
	// more than one domain object that matches the lookup values. These rows will need human intervention to
	// resolve the multiple references.
	Integer duplicateReferences = 0

	// A JSON List<Map> of error messages that were generated by the ETL and/or the batch processing logic
	// [
	//     { "code": "MISSING_REF", "field": "id", "msg": "Find by ID failed" },
	//     { "code": "DUP_REF", "field": "assetId", "msg": "Multiple records found" }
	// ]
	String errors = '[]'

	// A JSON Map of information regarding the query(ies) and the results of the find operation(s)
	// performed by the ETL process. The format will be similar to:
	//
	// "query": [
	//     {   "domain": "Application",
	//         "kv": {"id": null}
	//     },
	//     {   "domain": "Application",
	//         "kv": { "assetName": "CommGen", "assetType": "Application" }
	//     },
	//     {
	//         // Try finding in all classes but warn
	//         "domain": "Asset",
	//         "kv": { "assetName": "CommGen" },
	//         "warn": true,
	//     }
	// ],
	// "size": 2
	//
	String findInfo = '{}'

	// A JSON Map of information that would be used by the posting process to create a reference object
	// for the field if necessary. This would happen if the ETL didn't find the object and the subsequent
	// re-evaluation of the above query(ies) still was unable to find the reference object.
	// The JSON structure will look like the following:
	//
	// "create": {
	//     "domain": "Application",
	//     "assetName": "CommGen",
	//     "assetType": "Application",
	//     "TM Last Seen": "2017-12-24 03:23:24Z"
	// }
	//
	String createInfo = '{}'

	// A JSON Map of information that would be used by the posting process to update a reference object
	// for the field if necessary. This would happen if the ETL found the object or the subsequent processing
	// re-evaluation of the above query(ies) found thhe reference object. This is typically used with
	// Dependency references. The JSON structure will look like the following:
	//
	// "update": {
	// 	   "domain": "Application",
	// 	   "fields": {
	// 		   "TM Last Seen": "2017-12-24T03:23.485Z"
	// 	   }
	// }
	//
	String updateInfo = '{}'

	// The JSON List of fields and their meta attributes generated by the ETL process and utilized by the posting process
	// for the lookup, creating, updating of domains plus all of the individual property values etc.
	String fieldsInfo = '[]'

	Date lastUpdated

	static belongsTo = [
			importBatch: ImportBatch
	]

	static constraints = {
		createInfo nullable: false, size: 2..65635
		domainPrimaryId nullable: true
		duplicateReferences nullable: false, range: 0..1
		errors nullable: false, size: 2..65635
		fieldsInfo nullable: false, size: 2..16777215
		findInfo nullable: false, size: 2..65635
		lastUpdated nullable: true
		ignored nullable: false, range: 0..1
		sourceRowId nullable: false
		status nullable: false
		updateInfo nullable: false, size: 2..65635
		warn nullable: false, range: 0..1
	}

	static mapping = {
		id column: 'import_batch_record_id'
		createInfo sqltype: 'TEXT'
		domainPrimaryId sqltype: 'INT(11)'
		duplicateReferences sqltype: 'TINYINT(1)'
		errors sqltype: 'TEXT'
		fieldsInfo sqltype: 'MEDIUMTEXT'
		findInfo sqltype: 'TEXT'
		ignored sqltype: 'TINYINT(1)'
		sourceRowId sqltype: 'INT(8)'
		status sqltype: 'VARCHAR(32)'
		updateInfo sqltype: 'TEXT'
		warn sqltype: 'TINYINT(1)'
	}

	/**
	 * Used to convert the domain object into a Map object
	 * We may want to have an option to flatten some of the data from the fieldsInfo like
	 * each of the fields current value to render the datagrid (TBD)
	 */
	Map toMap(boolean minimalInfo = false) {
		Map domainMap = [
	        id: id,
			importBatch : importBatch.id,
			status: status.name(),
			operation: operation.name(),
			domainPrimaryId: domainPrimaryId,
			sourceRowId: sourceRowId,
			errorCount: errorCount,
			ignored: ignored,
			warn: warn,
			duplicateReferences: duplicateReferences,
			lastUpdated: lastUpdated
		]

		if (minimalInfo) {
			Map jsonPropertiesMap = [
			        errors: errorsAsList(),
					findInfo: findInfoAsMap(),
					createInfo: createInfoAsMap(),
					updateInfo: updateInfoAsMap()
			]
			domainMap.putAll(jsonPropertiesMap)
		}

		return domainMap
	}

	/**
	 * Used to access the errors property as an Object instead of JSON
	 */
	List<Map> errorsAsList() {
		return JsonUtil.parseJsonList(errors)
	}

	/**
	 * Used to access the createInfo property as an Object instead of JSON
	 */
	JSONObject createInfoAsMap() {
		return JsonUtil.parseJson(createInfo)
	}

	/**
	 * Used to access the fieldsInfo property as an Object instead of JSON
	 */
	JSONObject fieldsInfoAsMap() {
		return JsonUtil.parseJson(fieldsInfo)
	}

	/**
	 * Used to access the findInfo property as an Object instead of JSON
	 */
	JSONObject findInfoAsMap() {
		return JsonUtil.parseJson(findInfo)
	}

	/**
	 * Used to access the updateInfo property as an Object instead of JSON
	 */
	JSONObject updateInfoAsMap() {
		return JsonUtil.parseJson(updateInfo)
	}

}
